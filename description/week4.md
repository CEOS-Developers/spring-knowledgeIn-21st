## Week 4 Mission
### JWT Authentication

### ✅ JWT Authentication 방법에 대해서 알아보기
- JWT를 이용한 인증 방식(액세스 토큰, 리프레쉬 토큰)
    - JWT(Json Web Token) 이란?
        - JSON 포맷으로 정보를 안전하게 전송하기 위한 개방형 표준(RFC 7519)입니다.
        - **claim** 이라는 속성을 사용하여 필요한 정보를 서명(signature)을 통해 인증과 데이터 무결성을 보장하며, 주로 인증(Authentication)과 정보 교환을 위해 사용
        - JWT는 3개의 파트로 구성되어 있습니다.
            - Header : JWT의 타입과 해싱 알고리즘을 정의합니다.
            - Payload : JWT에 담길 정보를 담고 있습니다. (ex. 사용자 정보, 만료 시간 등)
            - Signature : Header와 Payload를 Base64Url로 인코딩한 후, 비밀키를 사용하여 서명합니다.
    - JWT 프로세스
        1. 사용자가 아이디와 비밀번호 혹은 소셜 로그인을 이용하여 서버에 로그인 요청을 보낸다.
        2. 서버는 secret Key를 사용해 JWT를 생성하고, 클라이언트에게 전달한다.
        3. 클라이언트는 JWT를 로컬 스토리지나 세션 스토리지에 저장한다.
        4. 클라이언트는 서버에 요청을 보낼 때 JWT를 Authorization 헤더에 담아 보낸다.
        5. 서버는 JWT를 검증하고, 유효한 경우 요청을 처리한다.

    - JWT Token
        - Access Token
            - 사용자가 서버에 요청을 보낼 때 사용하는 토큰입니다.
            - 서버에서 발급한 JWT를 사용하여 인증을 수행합니다.
            - Stateless 하기 때문에 서버에서 상태를 관리하지 않음 -> 토큰이 탈취 시 토큰이 만료될 때까지 방법이 없고, 만료 시간이 짧다면 서비스 이용 중에 유효시간이 갱신되지 않아 로그아웃 될 수 있기에 refresh token을 사용한다.
        - Refresh Token
            - Access Token이 만료되었을 때, 새로운 Access Token을 발급받기 위해 사용하는 토큰입니다.
            - Access Token의 유효시간을 짧게 하는 대신 유효시간이 긴 리프레시 토큰을 함께 발급하여 액세스 토큰 자체를 계속 갱신하는 것이 가능.


- 세션, 쿠키, OAuth 등 방식 조사하기
    - 쿠키 기반 인증
        - **쿠키** 는 브라우저에 저장되는 클래식한 방법입니다. (즉, 인증 정보를 클라이언트가 관리!)
        - 클라이언트가 서버에 첫 로그인 인증 요청을 보내면, 서버에서 응답으로 쿠키에 사용자 인증 정보를 담아서 보내고,
        - 서버에서 응답한 쿠키를 클라이언트에서 저장하고, 인증/인가 요청 마다 서버로 요청합니다.
        - 매우 간단한 방법인데, 인증 상태를 클라이언트의 인증 정보를 담은 쿠키의 요청을 받을 때마다 처리하므로 **Stateless**하다는 특징이 있습니다.
        - 하지만 단점으로는...
            - CSRF 공격에 취약합니다. (CSRF 공격은 사용자가 의도하지 않은 요청을 서버에 보내는 공격입니다.)
            - 쿠키는 브라우저에 저장되므로, 클라이언트가 쿠키를 조작할 수 있습니다.
            - 쿠키의 크기 제한이 있습니다. (일반적으로 4KB)
            - 쿠키는 도메인과 경로에 따라 제한됩니다. (즉, 다른 도메인에서는 사용할 수 없습니다.)
            - 즉, 보안상 위험하다!

    - 세션 기반 인증
        - **세션**으로 인증 정보를 관리하는 방법은
        - 클라이언트가 서버에 첫 로그인 인증 요청을 보내면, 서버가 인증 정보를 저장하고 세션ID를 클라이언트에게 전달합니다.
        - 서버에서 받은 세션ID를 클라이언트가 저장하고, 인증/인가 요청 마다 서버로 요청합니다.
        - 즉, 방금 쿠키와 다르게 서버에서 인증 정보를 관리하므로 **Stateful**하다는 특징이 있습니다.
        - 또한 한 사용자의 디바이스별 인증을 관리 가능합니다.
        - 하나의 계정을 공유로도 가능하다
        - 그리고 우리가 관리하니까 신고접수가 들어보면 판단해서 바로 막을 수 있겠져?
        - 서버에 저장한다고 했는데... 어디에 저장하지? 1. 메모리/하드디스크 2. 서버 DB
            - 만약에 하드디스크에 저장하면?
                - 서버가 재시작되면 세션이 날라가겠죠?
                - 그리고 서버가 여러 대일 경우, 세션을 공유할 수 없겠죠?
            - 그러면 DB에 저장하면?
                - 위보다는 당연히 느리겠지만 저 문제점을 해결할 수 있습니다!
                - 그러나 모든 정보를 DB에 저장해야하므로 연결 비용이 어마어마 할 것입니다...


### ✅ 액세스 토큰 발급 및 검증 로직 구현하기
#### CustomDetails

#### JwtAuthenticationFilter
- 로그인 시도 시 요청을 가로채서 인증 처리를 담당 하는 필터(/login) 요청 처리
- 성공 시 JWT를 생성하여 응답
    - **attemptAuthentication** : 로그인 정보(email, password) 추출 및 인증
    - **successfulAuthentication** : 인증 성공 시 accessToken과 refreshToken을 생성 후 JSON 형태로 응답 반환


#### JwtAuthorizationFilter
- JWT 토큰을 확인하고 인증 정보를 SecurityContext에 등록하는 필터
- 인증이 필요한 요청에서 유효한 JWT가 있으면 인증 처리
- **doFilterInternal** : JWT를 검증하고 인증 정보를 SecurityContext에 등록
    - JWT가 유효한 경우, Authentication 객체를 생성하고 SecurityContext에 저장
    - JWT가 유효하지 않은 경우, 401 Unauthorized 응답 반환

#### JwtUtil
- JWT 생성, 파싱, 검증, 갱신 등 핵심 로직 담당


#### 전체 흐름 정리
- 로그인 요청 -> JwtAuthenticationFilter 가 이메일/비밀번호 인증 후 토큰 발급
- 요청마다 JWT 포함 -> JwtAuthorizationFilter가 토큰을 인증하고 SecurityCOntext에 사용자 등록
- 토큰 만료 시 -> JwtUtil.reissueToken(...) 을 통해서 토큰 재발급 가능

### ✅ 회원가입 및 로그인 API 구현하고 테스트하기
#### AuthService - login
    - 로그인 시도 시 이메일과 비밀번호를 검증하고, JWT를 생성하여 반환
    - Spring Security 인증 객체인 CustomDetails를 직접 생성해 JWT 발급에 활용

- 로그아웃 사용 시
    - 로그아웃 시 JWT를 무효화하는 로직을 구현
        - JWT를 블랙리스트에 추가하여 유효하지 않도록 처리(백엔드가 처리)
        - JWT를 클라이언트에서 삭제하여 유효하지 않도록 처리(프론트엔드가 처리)
            - 사실 프론트랑 같이 하면 두번째 방식이 더 좋은데 ... 없으니 원하는 걸로 해보세용
            - 그래서 redis를 놔서 삭제하는 방법도 저는 사용함 ㅇㅇ
            - JWT는 stateless 여서 서버가 기억하는 세션이 없음 -> refresh token을 서버(또는 Redis)에 저장했다면 이를 삭제해서 로그아웃 구현 가능
            - 그렇기에, Redis에 저장하거나 DB 에 저장하는 방법을 사용함. (그러나 이건 지금 귀찮아서 안하겠음ㅎ)

#### AuthService - signup
    - 회원가입 시 이메일과 비밀번호를 검증하고, JWT를 생성하여 반환

### ✅ 토큰이 필요한 API 1개 이상 구현하고 테스트하기
#### 토큰 재발급(POST/auth/reissue)

#### 마이페이지 조회(GET /users/me)


### ✅ 리프레쉬 토큰 발급 로직 구현하고 테스트하기